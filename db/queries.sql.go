// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const createApplication = `-- name: CreateApplication :one
INSERT into applications (name, source, user_id)
values (?, ?, ?)
RETURNING id, user_id, name, source
`

type CreateApplicationParams struct {
	Name   string
	Source string
	UserID sql.NullInt64
}

func (q *Queries) CreateApplication(ctx context.Context, arg CreateApplicationParams) (Application, error) {
	row := q.queryRow(ctx, q.createApplicationStmt, createApplication, arg.Name, arg.Source, arg.UserID)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Source,
	)
	return i, err
}

const createLoginToken = `-- name: CreateLoginToken :one
INSERT INTO login_tokens (user_id, token)
values (?, ?)
RETURNING user_id, token, created_at
`

type CreateLoginTokenParams struct {
	UserID int64
	Token  string
}

func (q *Queries) CreateLoginToken(ctx context.Context, arg CreateLoginTokenParams) (LoginToken, error) {
	row := q.queryRow(ctx, q.createLoginTokenStmt, createLoginToken, arg.UserID, arg.Token)
	var i LoginToken
	err := row.Scan(&i.UserID, &i.Token, &i.CreatedAt)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, username)
VALUES (?, ?)
RETURNING id, email, username
`

type CreateUserParams struct {
	Email    string
	Username string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.queryRow(ctx, q.createUserStmt, createUser, arg.Email, arg.Username)
	var i User
	err := row.Scan(&i.ID, &i.Email, &i.Username)
	return i, err
}

const createUserSession = `-- name: CreateUserSession :one
INSERT INTO user_sessions (user_id, token)
values (?, ?)
RETURNING user_id, token, created_at
`

type CreateUserSessionParams struct {
	UserID int64
	Token  string
}

func (q *Queries) CreateUserSession(ctx context.Context, arg CreateUserSessionParams) (UserSession, error) {
	row := q.queryRow(ctx, q.createUserSessionStmt, createUserSession, arg.UserID, arg.Token)
	var i UserSession
	err := row.Scan(&i.UserID, &i.Token, &i.CreatedAt)
	return i, err
}

const deleteLoginToken = `-- name: DeleteLoginToken :exec
DELETE FROM login_tokens
where token = ?
`

func (q *Queries) DeleteLoginToken(ctx context.Context, token string) error {
	_, err := q.exec(ctx, q.deleteLoginTokenStmt, deleteLoginToken, token)
	return err
}

const deleteUserSession = `-- name: DeleteUserSession :exec
DELETE FROM user_sessions
where token = ?
`

func (q *Queries) DeleteUserSession(ctx context.Context, token string) error {
	_, err := q.exec(ctx, q.deleteUserSessionStmt, deleteUserSession, token)
	return err
}

const getApplication = `-- name: GetApplication :one
SELECT id, user_id, name, source
FROM applications
WHERE name = ?
`

func (q *Queries) GetApplication(ctx context.Context, name string) (Application, error) {
	row := q.queryRow(ctx, q.getApplicationStmt, getApplication, name)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Source,
	)
	return i, err
}

const getLoginToken = `-- name: GetLoginToken :one
SELECT user_id, token, created_at
FROM login_tokens
WHERE token = ?
`

func (q *Queries) GetLoginToken(ctx context.Context, token string) (LoginToken, error) {
	row := q.queryRow(ctx, q.getLoginTokenStmt, getLoginToken, token)
	var i LoginToken
	err := row.Scan(&i.UserID, &i.Token, &i.CreatedAt)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, email, username
FROM users
WHERE id = ?
`

func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) {
	row := q.queryRow(ctx, q.getUserStmt, getUser, id)
	var i User
	err := row.Scan(&i.ID, &i.Email, &i.Username)
	return i, err
}

const getUserApplications = `-- name: GetUserApplications :many
SELECT id, user_id, name, source
FROM applications
WHERE user_id = ?
`

func (q *Queries) GetUserApplications(ctx context.Context, userID sql.NullInt64) ([]Application, error) {
	rows, err := q.query(ctx, q.getUserApplicationsStmt, getUserApplications, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Application
	for rows.Next() {
		var i Application
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Source,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmailOrUsername = `-- name: GetUserByEmailOrUsername :one
SELECT id, email, username
FROM users
WHERE username = ?
    OR email = ?
`

type GetUserByEmailOrUsernameParams struct {
	Username string
	Email    string
}

func (q *Queries) GetUserByEmailOrUsername(ctx context.Context, arg GetUserByEmailOrUsernameParams) (User, error) {
	row := q.queryRow(ctx, q.getUserByEmailOrUsernameStmt, getUserByEmailOrUsername, arg.Username, arg.Email)
	var i User
	err := row.Scan(&i.ID, &i.Email, &i.Username)
	return i, err
}

const getUserSession = `-- name: GetUserSession :one
SELECT user_id, token, created_at
FROM user_sessions
WHERE token = ?
`

func (q *Queries) GetUserSession(ctx context.Context, token string) (UserSession, error) {
	row := q.queryRow(ctx, q.getUserSessionStmt, getUserSession, token)
	var i UserSession
	err := row.Scan(&i.UserID, &i.Token, &i.CreatedAt)
	return i, err
}

const updateApplication = `-- name: UpdateApplication :one
UPDATE applications
SET source = ?
WHERE id = ?
RETURNING id, user_id, name, source
`

type UpdateApplicationParams struct {
	Source string
	ID     int64
}

func (q *Queries) UpdateApplication(ctx context.Context, arg UpdateApplicationParams) (Application, error) {
	row := q.queryRow(ctx, q.updateApplicationStmt, updateApplication, arg.Source, arg.ID)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Source,
	)
	return i, err
}
